<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Round Timer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            /* PERMANENT DARK THEME DEFAULT */
            --bg-primary: #111827; 
            --bg-secondary: #1f2937; 
            --bg-tertiary: #374151; 
            --bg-accent: #4b5563; 
            --text-primary: #f9fafb; 
            --text-secondary: #d1d5db; 
            --text-accent: #6b7280; 
            
            /* PHASE COLORS */
            --color-warm-up: #f59e0b; /* Amber */
            --color-prepare: #facc15; /* Yellow */
            --color-work: #C51E3A;    /* Intense Cherry Red */
            --color-rest: #4ade80;    /* Green */
            --color-set-rest: #2dd4bf;/* Teal */
            
            /* BUTTONS */
            --btn-primary: #3b82f6; 
            --btn-secondary: #ef4444; 
            --btn-start: #22c55e; 
            --btn-save: #f59e0b; 
            --btn-rename: #8b5cf6; 
            --color-next-exercise-border: var(--color-set-rest); 
        }

        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.5s ease, color 0.3s ease;
        }
        
        /* Container transitions for color coding */
        #timer-container {
            transition: background-color 0.5s ease, color 0.3s ease, border-color 0.3s ease;
            /* Added explicit border for visibility against colored backgrounds */
            border: 4px solid rgba(255, 255, 255, 0.1); 
        }

        .timer-display { font-weight: 900; line-height: 1; }
        .btn { transition: all 0.2s ease; }
        .btn:active { transform: scale(0.95); }
        
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type="number"] { -moz-appearance: textfield; }
        
        .panel { transition: opacity 0.3s ease, transform 0.3s ease; }
        .panel.hidden { opacity: 0; transform: scale(0.98); pointer-events: none; display: none; }
        
        /* Custom Select Styling */
        .custom-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="white" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 0.7rem center;
            background-size: 1.2em;
            padding-right: 2.5rem;
        }

        /* Toggle Switch */
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg-accent); transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--btn-start); }
        input:checked + .slider:before { transform: translateX(22px); }

        /* Progress Bar */
        #progress-bar-container {
            width: 100%;
            height: 12px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            overflow: hidden;
            margin-top: 1rem;
        }
        #progress-bar {
            height: 100%;
            background-color: currentColor; /* Inherits text color */
            width: 100%;
            transition: width 1s linear;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-md mx-auto">
        <!-- Main Timer View -->
        <div id="timer-container" class="rounded-2xl shadow-2xl p-6 relative panel" style="background-color: var(--bg-secondary);">
            
            <!-- Display Area -->
            <div id="display-area" class="text-center mb-4 relative h-auto py-8 flex flex-col items-center justify-center rounded-xl">
                <div id="timer-display-content" class="z-0 w-full px-4">
                    <div id="phase-display" class="text-3xl font-bold uppercase mb-2">Prepare</div>
                    <div id="timer-display" class="text-8xl md:text-9xl timer-display tracking-tight tabular-nums whitespace-nowrap">--:--</div>
                    
                    <!-- Progress Bar -->
                    <div id="progress-bar-container">
                        <div id="progress-bar"></div>
                    </div>

                    <!-- Progress Display with Controls -->
                    <div id="progress-display" class="text-xl mt-6 flex items-center justify-center gap-6" style="color: inherit; opacity: 0.9;">
                        <button id="skip-back-btn" class="p-2 rounded-full hover:bg-white hover:bg-opacity-20 transition-colors btn" title="Previous Round">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                        </button>
                        
                        <span class="font-mono text-3xl select-none">
                            <div class="flex flex-col items-center leading-tight">
                                <span>Round <span id="current-round" class="font-bold">0</span>/<span id="total-rounds">0</span></span>
                                <span class="text-xl opacity-80">Set <span id="current-set">0</span>/<span id="total-sets">5</span></span>
                            </div>
                        </span>
                        
                        <button id="skip-forward-btn" class="p-2 rounded-full hover:bg-white hover:bg-opacity-20 transition-colors btn" title="Next Round">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
                        </button>
                    </div>
                </div>
                <div id="completion-message" class="z-10 hidden">
                    <h2 class="text-4xl md:text-5xl font-extrabold">Workout Completed!</h2>
                </div>
            </div>
            
            <div id="exercise-display-container" class="text-center mb-4 p-3 rounded-lg" style="background-color: rgba(0,0,0,0.2);">
                <h4 class="text-sm font-semibold uppercase opacity-75">Current Exercise</h4>
                <p id="exercise-display" class="text-2xl font-bold truncate">---</p>
            </div>
            
            <div id="main-preset-container" class="mb-4">
                <label for="main-preset-select" class="block text-center font-semibold uppercase text-sm mb-2 opacity-75">Workout Preset</label>
                <select id="main-preset-select" class="custom-select w-full font-bold py-3 px-4 rounded-lg text-lg btn" style="background-color: rgba(0,0,0,0.2); border: none; color: inherit;"></select>
            </div>

            <div id="next-exercise-container" class="text-center mb-4 p-3 rounded-lg hidden" style="background-color: rgba(0,0,0,0.2); border: 2px dashed currentColor;">
                <h4 class="text-sm font-semibold uppercase opacity-75">Next Exercise</h4>
                <p id="next-exercise-display" class="text-xl font-bold truncate">---</p>
            </div>

            <div id="controls-container" class="grid grid-cols-3 gap-4">
                <button id="start-pause-btn" class="text-white font-bold py-3 px-4 rounded-lg text-lg btn" style="background-color: var(--btn-start); color: white !important;">Start</button>
                <button id="reset-btn" class="text-white font-bold py-3 px-4 rounded-lg text-lg btn" style="background-color: var(--btn-secondary); color: white !important;">Reset</button>
                <button id="settings-btn" class="text-white font-bold py-3 px-4 rounded-lg text-lg btn" style="background-color: var(--btn-primary); color: white !important;">Settings</button>
            </div>
        </div>

        <!-- Settings Panel (Always Dark) -->
        <div id="settings-panel" class="rounded-2xl shadow-2xl p-6 hidden panel" style="background-color: var(--bg-secondary); color: var(--text-primary);">
            <div id="main-settings-content">
                <h3 class="text-2xl font-bold mb-6 text-center">Settings</h3>
                
                <div id="timer-inputs-container" class="grid grid-cols-2 gap-x-6 gap-y-4 mb-6"></div>

                <div class="mb-6 p-4 rounded-lg" style="background-color: var(--bg-tertiary);">
                    <!-- Warm Up Toggle -->
                    <div class="flex items-center justify-between">
                        <span class="font-bold">Warm up</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="warm-up-toggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>

                <div class="p-4 rounded-lg text-center grid grid-cols-1 gap-4 mb-6" style="background-color: var(--bg-tertiary);">
                    <div>
                        <h4 class="text-sm font-semibold uppercase" style="color: var(--text-secondary);">Total Workout Duration</h4>
                        <p id="total-duration-display" class="text-2xl font-bold">00:00</p>
                    </div>
                </div>

                <div class="mb-2">
                    <label for="preset-select" class="block text-center font-semibold uppercase text-sm mb-2" style="color: var(--text-secondary);">Presets</label>
                    <div id="preset-success-message" class="hidden text-center text-sm font-semibold p-2 rounded-lg mb-2" style="background-color: var(--color-work); color: var(--bg-primary);">Preset updated!</div>
                    <select id="preset-select" class="custom-select w-full text-white font-bold py-3 px-4 rounded-lg text-lg btn" style="background-color: var(--bg-tertiary); border: none;"></select>
                </div>
                
                <div class="grid grid-cols-3 gap-2 mb-4">
                    <button id="update-preset-btn" class="w-full text-white font-bold py-2 px-3 rounded-lg text-base btn" style="background-color: var(--btn-save);">Update</button>
                    <button id="save-as-new-preset-btn" class="w-full text-white font-bold py-2 px-3 rounded-lg text-base btn" style="background-color: var(--btn-primary);">Save as</button>
                    <button id="manage-presets-btn" class="w-full text-white font-bold py-2 px-3 rounded-lg text-base btn" style="background-color: var(--btn-rename);">Manage</button>
                </div>
                
                <div class="grid grid-cols-2 gap-2">
                    <button id="exercise-settings-btn" class="w-full text-white font-bold py-3 px-4 rounded-lg text-lg btn" style="background-color: var(--bg-accent);">Exercises & Rounds</button>
                    <button id="close-settings-btn" class="w-full text-white font-bold py-3 px-4 rounded-lg text-lg btn" style="background-color: var(--btn-start);">Done</button>
                </div>
            </div>

            <!-- Manage Presets View -->
            <div id="manage-presets-content" class="hidden">
                <h3 class="text-2xl font-bold mb-6 text-center">Manage Presets</h3>
                <div id="preset-management-list" class="space-y-2 max-h-96 overflow-y-auto pr-2"></div>
                <button id="back-to-settings-from-manage-btn" class="mt-6 w-full text-white font-bold py-3 px-4 rounded-lg text-lg btn" style="background-color: var(--btn-primary);">Back</button>
            </div>
        </div>
        
        <!-- Exercise Settings Panel (Always Dark) -->
        <div id="exercise-settings-panel" class="rounded-2xl shadow-2xl p-6 hidden panel" style="background-color: var(--bg-secondary); color: var(--text-primary);">
            <h3 class="text-xl font-bold mb-4 text-center">Exercises & Rounds</h3>
            <p class="text-xs text-center text-gray-400 mb-4">Set the name and round count for each set.</p>
            
            <div class="grid grid-cols-12 gap-2 mb-2 px-1 text-xs uppercase font-bold text-gray-400">
                <div class="col-span-1">#</div>
                <div class="col-span-8">Name</div>
                <div class="col-span-3 text-center">Rounds</div>
            </div>

            <div id="exercise-inputs-container" class="space-y-3 max-h-96 overflow-y-auto pr-2"></div>
            <button id="back-to-settings-from-exercises-btn" class="mt-6 w-full text-white font-bold py-3 px-4 rounded-lg text-lg btn" style="background-color: var(--btn-primary);">Back</button>
        </div>
    </div>

    <!-- Custom Modal -->
    <div id="modal-overlay" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <div id="modal-box" class="w-full max-w-sm rounded-2xl shadow-2xl p-6" style="background-color: var(--bg-secondary); color: var(--text-primary);">
            <h3 id="modal-title" class="text-xl font-bold mb-4 text-center"></h3>
            <p id="modal-text" class="mb-4 text-center text-gray-300"></p>
            <input type="text" id="modal-input" class="hidden w-full p-2 rounded-lg mb-4 text-center" style="background-color: var(--bg-primary); border: 1px solid var(--bg-accent); color: var(--text-primary);">
            <div class="flex justify-center gap-4">
                <button id="modal-cancel-btn" class="btn font-bold py-2 px-5 rounded-lg" style="background-color: var(--bg-tertiary);">Cancel</button>
                <button id="modal-confirm-btn" class="btn font-bold py-2 px-5 rounded-lg" style="background-color: var(--btn-primary);">Confirm</button>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const getElem = (id) => document.getElementById(id);
    const elements = {
        timerContainer: getElem('timer-container'),
        settingsPanel: getElem('settings-panel'),
        mainSettingsContent: getElem('main-settings-content'),
        managePresetsContent: getElem('manage-presets-content'),
        exerciseSettingsPanel: getElem('exercise-settings-panel'),
        timerDisplayContent: getElem('timer-display-content'),
        completionMessage: getElem('completion-message'),
        currentRoundDisplay: getElem('current-round'),
        totalRoundsDisplay: getElem('total-rounds'),
        currentSetDisplay: getElem('current-set'),
        totalSetsDisplay: getElem('total-sets'),
        exerciseDisplay: getElem('exercise-display'),
        nextExerciseContainer: getElem('next-exercise-container'),
        nextExerciseDisplay: getElem('next-exercise-display'),
        timerDisplay: getElem('timer-display'),
        phaseDisplay: getElem('phase-display'),
        controlsContainer: getElem('controls-container'),
        startPauseBtn: getElem('start-pause-btn'),
        resetBtn: getElem('reset-btn'),
        settingsBtn: getElem('settings-btn'),
        closeSettingsBtn: getElem('close-settings-btn'),
        exerciseSettingsBtn: getElem('exercise-settings-btn'),
        backToSettingsFromExercisesBtn: getElem('back-to-settings-from-exercises-btn'),
        totalDurationDisplay: getElem('total-duration-display'),
        timerInputsContainer: getElem('timer-inputs-container'),
        mainPresetContainer: getElem('main-preset-container'),
        mainPresetSelect: getElem('main-preset-select'),
        presetSelect: getElem('preset-select'),
        presetSuccessMessage: getElem('preset-success-message'),
        updatePresetBtn: getElem('update-preset-btn'),
        saveAsNewPresetBtn: getElem('save-as-new-preset-btn'),
        managePresetsBtn: getElem('manage-presets-btn'),
        presetManagementList: getElem('preset-management-list'),
        backToSettingsFromManageBtn: getElem('back-to-settings-from-manage-btn'),
        exerciseInputsContainer: getElem('exercise-inputs-container'),
        warmUpToggle: getElem('warm-up-toggle'),
        skipForwardBtn: getElem('skip-forward-btn'),
        skipBackBtn: getElem('skip-back-btn'),
        progressBar: getElem('progress-bar'),
        modalOverlay: getElem('modal-overlay'),
        modalBox: getElem('modal-box'),
        modalTitle: getElem('modal-title'),
        modalText: getElem('modal-text'),
        modalInput: getElem('modal-input'),
        modalCancelBtn: getElem('modal-cancel-btn'),
        modalConfirmBtn: getElem('modal-confirm-btn'),
    };

    let state = {};
    let modalResolve = null;
    let wakeLock = null;
    let audioCtx = null;

    const createExercise = (name, rounds) => ({ name: name, rounds: rounds });

    const defaultState = {
        timer: null, status: 'idle', phase: 'prepare', currentTime: 0, 
        totalPhaseTime: 0, 
        currentRound: 0, currentSet: 0,
        settings: {
            workTime: 35, restTime: 35, numSets: 4, restBetweenSets: 75, preStartDelay: 5,
            warmUpDuration: 300,
            exercises: [
                createExercise("Landmine row", 6),
                createExercise("Landmine press", 6),
                createExercise("Landmine squat", 6),
                createExercise("Kettlebell swings", 6)
            ]
        },
        presets: {
            "Barbell Strength": {
                workTime: 420, restTime: 30, numSets: 11, restBetweenSets: 75,
                exercises: [
                    createExercise("Barbell Cleans", 1), createExercise("Barbell Row", 1), createExercise("Zercher Squat", 1),
                    createExercise("Barbell Row", 1), createExercise("Hip thrust", 1), createExercise("Split squat", 1),
                    createExercise("Pallof press", 1), createExercise("Medius plate", 1), createExercise("Reverse hyper", 1),
                    createExercise("Hamstring slides", 1), createExercise("Crunches/Ab roller", 1)
                ]
            },
            "Thasmin": {
                workTime: 35, restTime: 35, numSets: 7, restBetweenSets: 75,
                exercises: [
                    createExercise("Kettlebell power cleans", 3), createExercise("Kettlebell swings", 3), createExercise("Split squat", 3),
                    createExercise("Squat", 3), createExercise("Hip thrust", 3), createExercise("Monster walk", 3), createExercise("Resistance band row", 3)
                ]
            }
        },
        warmUpEnabled: false,
        volume: 1.0, 
        lastPreset: "Thasmin"
    };
    
    // --- WAKE LOCK ---
    const requestWakeLock = async () => {
        try {
            if ('wakeLock' in navigator) {
                wakeLock = await navigator.wakeLock.request('screen');
                wakeLock.addEventListener('release', () => {});
            }
        } catch (err) {
            console.error(`${err.name}, ${err.message}`);
        }
    };

    document.addEventListener('visibilitychange', async () => {
        if (wakeLock !== null && document.visibilityState === 'visible' && state.status === 'running') {
            await requestWakeLock();
        }
    });

    const releaseWakeLock = async () => {
        if (wakeLock !== null) {
            await wakeLock.release();
            wakeLock = null;
        }
    };

    // --- PERSISTENCE ---
    const saveState = () => {
        try {
            const stateToSave = { 
                settings: state.settings, presets: state.presets, 
                warmUpEnabled: state.warmUpEnabled, volume: state.volume, lastPreset: state.lastPreset 
            };
            localStorage.setItem('tabataTimerStateV3', JSON.stringify(stateToSave));
        } catch (e) { console.error("Could not save state", e); }
    };

    const loadState = () => {
        try {
            const savedStateJSON = localStorage.getItem('tabataTimerStateV3');
            state = JSON.parse(JSON.stringify(defaultState));
            if (savedStateJSON) {
                const saved = JSON.parse(savedStateJSON);
                if (saved.settings) state.settings = { ...state.settings, ...saved.settings };
                if(state.settings.exercises.length > 0 && typeof state.settings.exercises[0] === 'string'){
                     state.settings.exercises = state.settings.exercises.map(name => createExercise(name, 6)); 
                }
                if (saved.presets) state.presets = saved.presets;
                if (typeof saved.warmUpEnabled === 'boolean') state.warmUpEnabled = saved.warmUpEnabled;
                state.volume = 1.0; 
                if (saved.lastPreset) state.lastPreset = saved.lastPreset;
            }
        } catch (e) {
            console.error("Could not load state", e);
            state = JSON.parse(JSON.stringify(defaultState));
        }
    };
    
    // --- UI GENERATORS (Stepper, Inputs, etc) ---
    const createStepperInput = (id, label, value) => {
        const container = document.createElement('div');
        container.id = `${id}-wrapper`;
        container.innerHTML = `
            <label for="${id}" class="block text-sm font-bold text-center" style="color: var(--text-secondary);">${label}</label>
            <div class="flex items-center gap-2 mt-1">
                <button data-action="decrement" data-target="${id}" class="w-10 h-10 text-xl font-bold rounded-md btn" style="background-color: var(--bg-tertiary); color: var(--text-primary);">-</button>
                <input type="number" id="${id}" value="${value}" class="timer-setting-input text-center block w-full border rounded-md shadow-sm py-2 px-3 focus:outline-none" style="background-color: var(--bg-primary); border-color: var(--bg-accent); color: var(--text-primary);">
                <button data-action="increment" data-target="${id}" class="w-10 h-10 text-xl font-bold rounded-md btn" style="background-color: var(--bg-tertiary); color: var(--text-primary);">+</button>
            </div>
        `;
        return container;
    };

    const generateTimerInputs = () => {
        const container = elements.timerInputsContainer;
        container.innerHTML = '';
        const s = state.settings;
        container.appendChild(createStepperInput('work-time', 'Work (s)', s.workTime));
        container.appendChild(createStepperInput('rest-time', 'Rest (s)', s.restTime));
        container.appendChild(createStepperInput('num-sets', 'Number of Sets', s.numSets));
        container.appendChild(createStepperInput('warm-up-duration', 'Warm Up (s)', s.warmUpDuration));
        container.appendChild(createStepperInput('rest-between-sets', 'Set Rest (s)', s.restBetweenSets));
        updateInputLayout();
    };
    
    const updateInputLayout = () => {
        const restWrapper = getElem('rest-between-sets-wrapper');
        const warmUpWrapper = getElem('warm-up-duration-wrapper');
        if (state.warmUpEnabled) {
            warmUpWrapper.classList.remove('hidden');
            restWrapper.classList.add('col-span-2');
        } else {
            warmUpWrapper.classList.add('hidden');
            restWrapper.classList.remove('col-span-2');
        }
        elements.warmUpToggle.checked = state.warmUpEnabled;
    };

    const generatePresetDropdown = () => {
        const selects = [elements.presetSelect, elements.mainPresetSelect];
        selects.forEach(select => {
            if (!select) return;
            select.innerHTML = '';
            Object.keys(state.presets).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
            if (state.lastPreset && state.presets[state.lastPreset]) select.value = state.lastPreset;
        });
    };

    const generateExerciseInputs = () => {
        const container = elements.exerciseInputsContainer;
        container.innerHTML = '';
        const numSets = state.settings.numSets;
        adjustExerciseArray(numSets); 
        for (let i = 0; i < numSets; i++) {
            const ex = state.settings.exercises[i] || createExercise("", 6);
            const row = document.createElement('div');
            row.className = "grid grid-cols-12 gap-2 items-center";
            row.innerHTML = `
                <div class="col-span-1 text-center font-bold text-gray-500">${i+1}</div>
                <div class="col-span-8">
                    <input type="text" data-field="name" data-index="${i}" value="${ex.name}" class="exercise-input w-full border rounded-md py-2 px-3 focus:outline-none" style="background-color: var(--bg-tertiary); border-color: var(--bg-accent); color: var(--text-primary);">
                </div>
                <div class="col-span-3">
                    <input type="number" data-field="rounds" data-index="${i}" value="${ex.rounds}" class="exercise-input w-full text-center border rounded-md py-2 px-1 focus:outline-none" style="background-color: var(--bg-tertiary); border-color: var(--bg-accent); color: var(--text-primary);">
                </div>
            `;
            container.appendChild(row);
        }
    };

    // --- WEB AUDIO API (Fix for sound) ---
    const initAudio = () => {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    };

    const playTone = (freq, duration, type = 'sine') => {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
        osc.stop(audioCtx.currentTime + duration);
    };

    const playSound = (type) => {
        initAudio(); // Ensure context is ready
        if (type === 'setEnd') {
            // Ding-Dong Chime for set end
            playTone(600, 0.1); 
            setTimeout(() => playTone(800, 0.6), 100);
        } else if (type === 'beep') {
            // Arcade Jump Logic (Replacing standard beep)
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }
    };

    const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
        const secs = (seconds % 60).toString().padStart(2, '0');
        return `${mins}:${secs}`;
    };

    const getCurrentRoundLimit = () => {
        const idx = Math.max(0, state.currentSet - 1);
        if(state.settings.exercises[idx]) return state.settings.exercises[idx].rounds;
        return 6; 
    }

    const setPhase = (phaseName, duration) => {
        state.phase = phaseName;
        state.currentTime = duration;
        state.totalPhaseTime = duration;
    }

    const tick = () => {
        if (state.currentTime > 0) {
            state.currentTime--;
            updateDisplay();
        } else {
            // Transitions
            if (state.phase === 'warmUp') {
                setPhase('prepare', state.settings.preStartDelay);
            } else if (state.phase === 'prepare') {
                state.currentRound = 1; 
                state.currentSet = 1;
                setPhase('work', state.settings.workTime);
            } else if (state.phase === 'work') {
                const roundsForThisExercise = getCurrentRoundLimit();
                if (state.currentRound >= roundsForThisExercise) { 
                    playSound('setEnd'); 
                    if (state.currentSet >= state.settings.numSets) { 
                        workoutComplete(); return;
                    }
                    if (state.settings.restBetweenSets > 0) {
                        setPhase('setRest', state.settings.restBetweenSets);
                    } else {
                        state.currentSet++; 
                        state.currentRound = 1; 
                        setPhase('work', state.settings.workTime);
                    }
                } else { 
                    playSound('beep'); 
                    setPhase('rest', state.settings.restTime);
                }
            } else if (state.phase === 'rest') {
                state.currentRound++; 
                setPhase('work', state.settings.workTime);
            } else if (state.phase === 'setRest') {
                state.currentSet++; 
                state.currentRound = 1; 
                setPhase('work', state.settings.workTime);
            }
            updateDisplay();
        }
    };
    
    const skipForward = () => {
        if (state.phase === 'complete') return;
        initAudio();
        const roundLimit = getCurrentRoundLimit();

        if (state.phase === 'warmUp' || state.phase === 'prepare') {
            state.currentRound = 1; state.currentSet = 1;
        } else {
            state.currentRound++;
            if (state.currentRound > roundLimit) {
                state.currentSet++;
                state.currentRound = 1;
                if (state.currentSet > state.settings.numSets) {
                    workoutComplete(); return;
                }
            }
        }
        setPhase('work', state.settings.workTime); // Always skip to work
        updateDisplay();
    };

    const skipBack = () => {
        if (state.phase === 'complete') return;
        if (state.phase === 'warmUp' || state.phase === 'prepare') return;

        state.currentRound--;
        if (state.currentRound < 1) {
            state.currentSet--;
            if (state.currentSet < 1) {
                reset(false);
                if (state.warmUpEnabled) setPhase('warmUp', state.settings.warmUpDuration);
                else setPhase('prepare', state.settings.preStartDelay);
                updateDisplay(); return;
            } else {
                const prevSetIdx = Math.max(0, state.currentSet - 1);
                state.currentRound = state.settings.exercises[prevSetIdx].rounds;
            }
        }
        setPhase('work', state.settings.workTime);
        updateDisplay();
    };

    const workoutComplete = () => {
        clearInterval(state.timer);
        state.status = 'idle'; state.phase = 'complete';
        playSound('setEnd');
        elements.timerDisplayContent.classList.add('hidden');
        elements.completionMessage.classList.remove('hidden');
        elements.nextExerciseContainer.classList.add('hidden');
        releaseWakeLock();
        updateButtonState();
        applyPhaseColors('complete');
    };

    const start = () => {
        if (state.status === 'running') return;
        elements.mainPresetContainer.classList.add('hidden');
        initAudio(); // Initialize audio on first click
        requestWakeLock();

        if (state.status === 'idle' || state.phase === 'complete') {
            reset(false);
            if (state.warmUpEnabled) setPhase('warmUp', state.settings.warmUpDuration);
            else setPhase('prepare', state.settings.preStartDelay);
        }
        state.status = 'running';
        state.timer = setInterval(tick, 1000);
        updateButtonState();
        updateDisplay();
    };

    const pause = () => {
        if (state.status !== 'running') return;
        clearInterval(state.timer);
        state.status = 'paused';
        releaseWakeLock();
        updateButtonState();
    };

    const reset = (fullReset = true) => {
        clearInterval(state.timer);
        state.status = 'idle';
        state.phase = 'prepare';
        state.currentRound = 0; state.currentSet = 0;
        state.currentTime = 0; state.totalPhaseTime = 0;
        releaseWakeLock();
        if (fullReset) {
            elements.timerDisplayContent.classList.remove('hidden');
            elements.completionMessage.classList.add('hidden');
            elements.nextExerciseContainer.classList.add('hidden');
            elements.mainPresetContainer.classList.remove('hidden');
            updateButtonState();
            updateDisplay(true);
            applyPhaseColors('idle'); // Reset colors
        }
    };

    // --- COLOR & VISUAL LOGIC ---
    const applyPhaseColors = (phase) => {
        let bgColor, textColor;
        
        switch(phase) {
            case 'warmUp':
                bgColor = 'var(--color-warm-up)';
                textColor = 'black'; 
                break;
            case 'prepare':
                bgColor = 'var(--color-prepare)';
                textColor = 'black'; 
                break;
            case 'work':
                bgColor = 'var(--color-work)';
                textColor = 'white'; 
                break;
            case 'rest':
                bgColor = 'var(--color-rest)';
                textColor = 'black'; 
                break;
            case 'setRest':
                bgColor = 'var(--color-set-rest)';
                textColor = 'black'; 
                break;
            default: // idle, complete
                bgColor = 'var(--bg-primary)';
                textColor = 'var(--text-primary)';
        }

        if (phase === 'idle' || phase === 'complete') {
            document.body.style.backgroundColor = ''; 
            elements.timerContainer.style.backgroundColor = ''; 
            document.body.style.color = ''; 
            elements.timerContainer.style.color = '';
        } else {
            document.body.style.backgroundColor = bgColor;
            elements.timerContainer.style.backgroundColor = bgColor;
            document.body.style.color = textColor;
            elements.timerContainer.style.color = textColor;
        }
    };

    const updateDisplay = (isInitialReset = false) => {
        // Update Colors
        applyPhaseColors(state.phase);

        // Update Progress Bar
        if (state.totalPhaseTime > 0 && state.status !== 'idle') {
            const percentage = (state.currentTime / state.totalPhaseTime) * 100;
            elements.progressBar.style.width = `${percentage}%`;
        } else {
            elements.progressBar.style.width = '100%';
        }

        if (isInitialReset) {
            elements.phaseDisplay.textContent = "GET READY!";
            elements.timerDisplay.textContent = "--:--";
            elements.exerciseDisplay.textContent = state.settings.exercises[0] ? state.settings.exercises[0].name : "---";
        } else {
            elements.timerDisplay.textContent = formatTime(state.currentTime);
            elements.phaseDisplay.textContent = state.phase.replace('setRest', 'SET REST').replace('warmUp', 'WARM UP');
            
            const exerciseIndex = (state.phase === 'prepare' || state.phase === 'warmUp') 
                ? 0 
                : Math.max(0, state.currentSet - 1);
            const currentEx = state.settings.exercises[exerciseIndex];
            elements.exerciseDisplay.textContent = currentEx ? currentEx.name : '---';
        }
        
        const roundLimit = getCurrentRoundLimit();
        elements.currentRoundDisplay.textContent = state.currentRound;
        elements.totalRoundsDisplay.textContent = (state.phase === 'prepare' || state.phase === 'warmUp') 
            ? state.settings.exercises[0].rounds 
            : roundLimit;

        elements.currentSetDisplay.textContent = state.currentSet;
        elements.totalSetsDisplay.textContent = state.settings.numSets;

        if (state.phase === 'setRest' && state.currentSet < state.settings.numSets) {
            const nextEx = state.settings.exercises[state.currentSet];
            elements.nextExerciseDisplay.textContent = nextEx ? nextEx.name : '---';
            elements.nextExerciseContainer.classList.remove('hidden');
        } else {
            elements.nextExerciseContainer.classList.add('hidden');
        }
    };
    
    const updateDurations = () => {
        let totalSeconds = 0;
        if(state.warmUpEnabled) totalSeconds += state.settings.warmUpDuration;
        state.settings.exercises.forEach((ex, index) => {
            if(index >= state.settings.numSets) return;
            const rounds = parseInt(ex.rounds) || 1;
            const setDuration = (state.settings.workTime * rounds) + (state.settings.restTime * (rounds - 1));
            totalSeconds += setDuration;
            if(index < state.settings.numSets - 1) totalSeconds += state.settings.restBetweenSets;
        });
        elements.totalDurationDisplay.textContent = formatTime(totalSeconds);
    };

    const updateButtonState = () => {
        const startBtn = elements.startPauseBtn;
        if (state.status === 'running') {
            elements.controlsContainer.className = 'flex justify-center';
            elements.resetBtn.classList.add('hidden');
            elements.settingsBtn.classList.add('hidden');
            startBtn.textContent = 'Pause';
            startBtn.style.backgroundColor = 'var(--bg-accent)';
        } else if (state.status === 'paused') {
            elements.controlsContainer.className = 'grid grid-cols-3 gap-4';
            elements.resetBtn.classList.remove('hidden');
            elements.settingsBtn.classList.remove('hidden');
            startBtn.textContent = 'Resume';
            startBtn.style.backgroundColor = 'var(--btn-start)';
        } else { 
            elements.controlsContainer.className = 'grid grid-cols-3 gap-4';
            elements.resetBtn.classList.remove('hidden');
            elements.settingsBtn.classList.remove('hidden');
            startBtn.textContent = 'Start';
            startBtn.style.backgroundColor = 'var(--btn-start)';
        }
    };

    const adjustExerciseArray = (newSize) => {
        const currentExercises = state.settings.exercises;
        if (!Array.isArray(currentExercises)) state.settings.exercises = [];
        while (newSize > state.settings.exercises.length) {
            state.settings.exercises.push(createExercise("", 6));
        }
        state.settings.exercises.length = newSize;
    };

    const handleSettingsChange = (e) => {
        const oldNumSets = state.settings.numSets;
        state.settings.workTime = parseInt(getElem('work-time').value, 10) || 0;
        state.settings.restTime = parseInt(getElem('rest-time').value, 10) || 0;
        state.settings.numSets = parseInt(getElem('num-sets').value, 10) || 0;
        state.settings.restBetweenSets = parseInt(getElem('rest-between-sets').value, 10) || 0;
        state.settings.warmUpDuration = parseInt(getElem('warm-up-duration').value, 10) || 0;
        state.warmUpEnabled = elements.warmUpToggle.checked;

        if (state.settings.numSets !== oldNumSets) {
            adjustExerciseArray(state.settings.numSets);
            generateExerciseInputs();
        }
        updateInputLayout();
        updateDurations();
        saveState();
    };
    
    const handleExerciseInputChange = (e) => {
        const index = parseInt(e.target.dataset.index, 10);
        const field = e.target.dataset.field;
        if (state.settings.exercises[index]) {
            state.settings.exercises[index][field] = e.target.value;
            saveState();
            updateDurations(); 
        }
    };

    const applyPreset = (presetName) => {
        const presetSettings = state.presets[presetName];
        if (!presetSettings) return;
        state.lastPreset = presetName;
        
        let cleanExercises = presetSettings.exercises || [];
        if(cleanExercises.length > 0 && typeof cleanExercises[0] === 'string') {
             cleanExercises = cleanExercises.map(n => createExercise(n, presetSettings.roundsPerSet || 6));
        }

        const cleanPresetSettings = {
            workTime: presetSettings.workTime,
            restTime: presetSettings.restTime,
            numSets: presetSettings.numSets,
            restBetweenSets: presetSettings.restBetweenSets,
            exercises: cleanExercises,
            warmUpDuration: presetSettings.warmUpDuration || 300
        };

        state.settings = { ...defaultState.settings, ...cleanPresetSettings };
        updateUIFromState();
        saveState();
    };

    const updateUIFromState = () => {
        generateTimerInputs();
        generatePresetDropdown();
        generateExerciseInputs();
        updateDurations();
        reset(true);
    };

    const showPanel = (panelToShow) => {
        [elements.timerContainer, elements.settingsPanel, elements.exerciseSettingsPanel].forEach(panel => {
            panel.classList.toggle('hidden', panel !== panelToShow);
        });
    };
    
    const showModal = (type, title, text, placeholder = '') => {
        return new Promise(resolve => {
            modalResolve = resolve;
            elements.modalTitle.textContent = title;
            elements.modalText.textContent = text;
            if (type === 'prompt') {
                elements.modalInput.classList.remove('hidden');
                elements.modalInput.value = '';
                elements.modalInput.placeholder = placeholder;
            } else {
                elements.modalInput.classList.add('hidden');
            }
            elements.modalOverlay.classList.remove('hidden');
            elements.modalOverlay.classList.add('flex');
        });
    };

    const hideModal = (value) => {
        elements.modalOverlay.classList.add('hidden');
        elements.modalOverlay.classList.remove('flex');
        if (modalResolve) { modalResolve(value); modalResolve = null; }
    };

    const showSuccessMessage = (message) => {
        elements.presetSuccessMessage.textContent = message;
        elements.presetSuccessMessage.classList.remove('hidden');
        setTimeout(() => elements.presetSuccessMessage.classList.add('hidden'), 2500);
    };

    // --- LISTENERS ---
    elements.startPauseBtn.addEventListener('click', () => (state.status === 'running') ? pause() : start());
    elements.resetBtn.addEventListener('click', () => reset(true));
    elements.settingsBtn.addEventListener('click', () => showPanel(elements.settingsPanel));
    elements.closeSettingsBtn.addEventListener('click', () => { showPanel(elements.timerContainer); reset(true); });
    elements.exerciseSettingsBtn.addEventListener('click', () => showPanel(elements.exerciseSettingsPanel));
    elements.backToSettingsFromExercisesBtn.addEventListener('click', () => showPanel(elements.settingsPanel));
    elements.backToSettingsFromManageBtn.addEventListener('click', () => {
        elements.managePresetsContent.classList.add('hidden');
        elements.mainSettingsContent.classList.remove('hidden');
    });

    elements.managePresetsBtn.addEventListener('click', () => {
        elements.mainSettingsContent.classList.add('hidden');
        elements.managePresetsContent.classList.remove('hidden');
        generatePresetManagementList();
    });

    elements.timerInputsContainer.addEventListener('input', e => { if (e.target.matches('.timer-setting-input')) handleSettingsChange(e); });
    elements.timerInputsContainer.addEventListener('click', e => {
        const btn = e.target.closest('[data-action]');
        if (!btn) return;
        const input = getElem(btn.dataset.target);
        let value = parseInt(input.value, 10);
        const step = (input.id.includes('time') || input.id.includes('duration')) ? 5 : 1;
        input.value = Math.max(0, btn.dataset.action === 'increment' ? value + step : value - step);
        input.dispatchEvent(new Event('input', { bubbles: true }));
    });

    elements.exerciseInputsContainer.addEventListener('input', e => {
        if (e.target.matches('.exercise-input')) handleExerciseInputChange(e);
    });

    elements.warmUpToggle.addEventListener('change', handleSettingsChange);
    elements.presetSelect.addEventListener('change', (e) => applyPreset(e.target.value));
    elements.mainPresetSelect.addEventListener('change', (e) => applyPreset(e.target.value));

    elements.skipForwardBtn.addEventListener('click', skipForward);
    elements.skipBackBtn.addEventListener('click', skipBack);

    elements.saveAsNewPresetBtn.addEventListener('click', async () => {
        const newName = await showModal('prompt', 'Save as New Preset', 'Enter a name for your new preset.');
        if (newName && newName.trim() !== '') {
            const presetToSave = JSON.parse(JSON.stringify(state.settings)); 
            state.presets[newName] = presetToSave;
            state.lastPreset = newName;
            saveState();
            generatePresetDropdown();
            showSuccessMessage(`Preset "${newName}" saved!`);
        }
    });

    elements.updatePresetBtn.addEventListener('click', async () => {
        const presetToUpdate = elements.presetSelect.value;
        const confirmed = await showModal('confirm', 'Update Preset', `Overwrite "${presetToUpdate}" with current settings?`);
        if (confirmed) {
            state.presets[presetToUpdate] = JSON.parse(JSON.stringify(state.settings));
            saveState();
            showSuccessMessage(`Preset "${presetToUpdate}" updated!`);
        }
    });
    
    elements.modalConfirmBtn.addEventListener('click', () => {
        const inputValue = elements.modalInput.value;
        hideModal(elements.modalInput.classList.contains('hidden') ? true : inputValue);
    });
    elements.modalCancelBtn.addEventListener('click', () => hideModal(null));

    const generatePresetManagementList = () => {
        const container = elements.presetManagementList;
        container.innerHTML = '';
        Object.keys(state.presets).forEach(name => {
            const item = document.createElement('div');
            item.className = 'flex items-center justify-between p-3 rounded-lg bg-gray-700';
            item.innerHTML = `
                <span class="font-medium truncate pr-2">${name}</span>
                <div class="flex-shrink-0 flex gap-2">
                    <button data-action="delete" data-preset="${name}" class="btn text-sm py-1 px-3 rounded-md bg-red-500 hover:bg-red-600">Delete</button>
                </div>
            `;
            container.appendChild(item);
        });
        
        container.querySelectorAll('button[data-action="delete"]').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                const name = e.target.dataset.preset;
                if(Object.keys(state.presets).length <= 1) return; 
                const confirm = await showModal('confirm', 'Delete?', `Delete "${name}"?`);
                if(confirm) {
                    delete state.presets[name];
                    if(state.lastPreset === name) state.lastPreset = Object.keys(state.presets)[0];
                    saveState();
                    generatePresetManagementList();
                    generatePresetDropdown();
                }
            });
        });
    };

    loadState();
    if (state.lastPreset && state.presets[state.lastPreset]) applyPreset(state.lastPreset);
    else updateUIFromState();
});
</script>
</body>
</html>
